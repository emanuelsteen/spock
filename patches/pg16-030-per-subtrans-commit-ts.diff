diff --git a/src/backend/access/transam/commit_ts.c b/src/backend/access/transam/commit_ts.c
index b897fabc70..6be32cec80 100644
--- a/src/backend/access/transam/commit_ts.c
+++ b/src/backend/access/transam/commit_ts.c
@@ -59,6 +59,22 @@ typedef struct CommitTimestampEntry
 	RepOriginId nodeid;
 } CommitTimestampEntry;
 
+/*
+ * pgEdge requires to override the CommitTimestampEntry for individual
+ * subtransactions in the case that delta-apply needs to override losing
+ * last-update-wins. spock_apply_heap will then perform this (rare)
+ * update in a subtransaction so that this individual row gets its own
+ * xmin. By overriding this xid's CommitTsData the row can retain its
+ * original CommitTsData and not assume that of the overall replication
+ * transaction.
+ */
+typedef struct SubTransactionCommitTsEntry
+{
+	TransactionId	xid;
+	TimestampTz		time;
+	RepOriginId		nodeid;
+} SubTransactionCommitTsEntry;
+
 #define SizeOfCommitTimestampEntry (offsetof(CommitTimestampEntry, nodeid) + \
 									sizeof(RepOriginId))
 
@@ -77,6 +93,14 @@ static SlruCtlData CommitTsCtlData;
 
 #define CommitTsCtl (&CommitTsCtlData)
 
+/*
+ * Data to override CommitTsData for individual subtransaction.
+ * This is needed for pgEdge Delta Apply CommitTs tracking.
+ */
+static SubTransactionCommitTsEntry	   *sub_trans_commit_ts_data = NULL;
+static int								sub_trans_commit_n_alloc = 0;
+static int								sub_trans_commit_n_used = 0;
+
 /*
  * We keep a cache of the last value set in shared memory.
  *
@@ -205,6 +229,15 @@ TransactionTreeSetCommitTsData(TransactionId xid, int nsubxids,
 	if (TransactionIdPrecedes(ShmemVariableCache->newestCommitTsXid, newestXact))
 		ShmemVariableCache->newestCommitTsXid = newestXact;
 	LWLockRelease(CommitTsLock);
+
+	/* Cleanup subtransaction commit ts override data */
+	if (sub_trans_commit_ts_data != NULL)
+	{
+		pfree(sub_trans_commit_ts_data);
+		sub_trans_commit_ts_data = NULL;
+		sub_trans_commit_n_used = 0;
+		sub_trans_commit_n_alloc = 0;
+	}
 }
 
 /*
@@ -243,12 +276,24 @@ TransactionIdSetCommitTs(TransactionId xid, TimestampTz ts,
 {
 	int			entryno = TransactionIdToCTsEntry(xid);
 	CommitTimestampEntry entry;
+	int			i;
 
 	Assert(TransactionIdIsNormal(xid));
 
 	entry.time = ts;
 	entry.nodeid = nodeid;
 
+	/* Override the time and nodeid if an individual entry was recorded */
+	for (i = 0; i < sub_trans_commit_n_used; i++)
+	{
+		if (sub_trans_commit_ts_data[i].xid == xid)
+		{
+			entry.time = sub_trans_commit_ts_data[i].time;
+			entry.nodeid = sub_trans_commit_ts_data[i].nodeid;
+			break;
+		}
+	}
+
 	memcpy(CommitTsCtl->shared->page_buffer[slotno] +
 		   SizeOfCommitTimestampEntry * entryno,
 		   &entry, SizeOfCommitTimestampEntry);
@@ -369,6 +414,57 @@ GetLatestCommitTsData(TimestampTz *ts, RepOriginId *nodeid)
 	return xid;
 }
 
+/*
+ * Record a different CommitTsData entry for a given subtransaction
+ *
+ * pgEdge uses this in Spock to track the correct commit ts and origin
+ * in case a delta apply had to force an update to a row that would
+ * otherwise not be updated because last-update-wins found in favor of
+ * the existing local row.
+ */
+void
+SubTransactionIdSetCommitTsData(TransactionId xid, TimestampTz ts,
+								RepOriginId nodeid)
+{
+	SubTransactionCommitTsEntry *ent;
+
+	/* Ensure we have space in the tracking array */
+	if (sub_trans_commit_n_used >= sub_trans_commit_n_alloc)
+	{
+		/*
+		 * We allocate this in the top memory context. This could accumulate
+		 * if transactions over and over record entries and then abort.
+		 * Under the Spock apply worker that cannot happen as such error
+		 * condition would restart the backend.
+		 */
+		MemoryContext	oldcontext;
+
+		oldcontext = MemoryContextSwitchTo(TopMemoryContext);
+
+		if (sub_trans_commit_ts_data == NULL)
+		{
+			sub_trans_commit_n_alloc = 32;
+			sub_trans_commit_ts_data = (SubTransactionCommitTsEntry *)
+									   palloc(sizeof(SubTransactionCommitTsEntry) * sub_trans_commit_n_alloc);
+		}
+		else
+		{
+			sub_trans_commit_n_alloc *= 2;
+			sub_trans_commit_ts_data = (SubTransactionCommitTsEntry *)
+									   repalloc(sub_trans_commit_ts_data,
+												sizeof(SubTransactionCommitTsEntry) * sub_trans_commit_n_alloc);
+		}
+
+		MemoryContextSwitchTo(oldcontext);
+	}
+
+	ent = &sub_trans_commit_ts_data[sub_trans_commit_n_used++];
+
+	ent->xid = xid;
+	ent->time = ts;
+	ent->nodeid = nodeid;
+}
+
 static void
 error_commit_ts_disabled(void)
 {
diff --git a/src/include/access/commit_ts.h b/src/include/access/commit_ts.h
index 5087cdce51..bc6a3112b1 100644
--- a/src/include/access/commit_ts.h
+++ b/src/include/access/commit_ts.h
@@ -26,6 +26,9 @@ extern bool TransactionIdGetCommitTsData(TransactionId xid,
 										 TimestampTz *ts, RepOriginId *nodeid);
 extern TransactionId GetLatestCommitTsData(TimestampTz *ts,
 										   RepOriginId *nodeid);
+extern void SubTransactionIdSetCommitTsData(TransactionId xid,
+											TimestampTz ts,
+											RepOriginId nodeid);
 
 extern Size CommitTsShmemBuffers(void);
 extern Size CommitTsShmemSize(void);
